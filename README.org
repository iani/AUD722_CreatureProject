#+title: Readme

How to use this folder and make your own Crature.

* 1. Prepare your audio file(s) for loading.

** 1.1.  Preparing the audio file for your own creature

Your audio file should be a mono (1 channel) wav file.  Its name should be the same as your class name, *in lower case* and the extension should be =.wav=. For example, if your class is named =Cricket= then the audio file should be named =cricket.wav=. 

Note: You can also tell your creature class to load another file by editing its fileName class method. For example:

#+begin_src sclang
	*fileName { // tell your creature to use file basssdrum.wav
		// the file must be in the CreatureAudio folder, together with all other audio files.
		^"bassdrum.wav";
	}
#+end_src

Put your audio file in folder CreatureAudio in your own repository. 

** =~/CreaturesAudio/= is the folder for all audio files for the Creature project

Your audio file and all audio files of all other creatures should be placed together in a folder named =CreaturesAudio=. The folder =CreaturesAudio= should be directly in your home folder like this: =~/CreaturesAudio/=.  You can download the CreatureAudio folder with the files collected by all project members from github, as explained in the next subsection.

** 1.1. Cloning the folder with all audio files from github

Clone the repository https://github.com/iani/CreatureAudio into your home folder. This repository contains the audio files for all creatures.  You should put your own audio file in side this folder.  It will be loaded by your creature class when the server boots.

* 2. Prepare your classes

** 2.1. Put the class code inside your SuperCollider Extensions folder and recompile

The class code is found in repository

https://github.com/iani/AUD722_CreatureProject

You can clone this with:

git clone https://github.com/iani/AUD722_CreatureProject.git

Put the cloned repository in your SuperCollider Extensions folder.

Note: To find the location of the SuperCollider Extensions folder, run this in
SuperCollider:

#+begin_src sclang
Platform.userExtensionDir; 
#+end_src

** 2.2. Recompile the supercollider library (Control-Shift-l).

You should recompile the supercollider library every time that you make a change to any of the classes inside this folder.

* 3. Create your creature
** 3.1 Define your creature as a subclass of Creature.

Each creature is defined by a class whose code is contained in a single file.
Creature class files are found in folder =CreatureClasses= of the present repository.  Creature classes must be a subclass of =Creature=.  For this purpose, your Creature class definition code must start like this: This is done by writing this in the of the class definition code:

#+begin_src sclang
Cricket : Creature {
	// your class code here
}
#+end_src

As an example, we will create here a creature class named "Cricket".  It will use a buffer with a recording of crickets.  See  

1. Create a file named =Cricket.sc=
2. Place the file inside the Extensions directory (see above).
3. The Cricket creature class must be a subclass of Creature to work. The code for this is:

#+begin_src sclang
Cricket : Creature {
	// own methods code placed here:
	// day { /* code here! */ }
	// night {  /* code here! */  }
	// ...
}
#+end_src

* 4. Customize the behavior of your creature

There are several ways to customize sounds to your creature:
** 4.1 Add actions to the actions environment

/Note: This technique is good for prototyping, because it does not require recompiling the Class library./

You can add actions to your class using the addActions method. These changes take effect immediately, without having to recompile the library.  The changes affect only the one instance that you send the addActions method to. If you send =addActions= to your class directly, then addActions operates on the default instance of that class. But you can also send =addActions= to any instance of your class, or any Creature instance in general. Here is an example, operating on the Cricket Creature class:

#+begin_src sclang
Cricket addActions: (
	buzz: {
		// this is the sound of the action
		{ PinkNoise.ar(Env.perc(0.01, 0.1).kr(2)).dup / 10 }.play;
		0.2; // this is the duration of the action
		// you must provide a duration for the action to work when chaining actions
	}
	// you can add more actions to different keys here. 
	// , buzz2 {
	// more sound production code here.
	// }
);
#+end_src

** 4.2 Add methods to your Creature subclass

/Note: Use this technique when you want to add a behaviour permanently./

Add methods to your Creature subclass that create sounds or perform tasks. This requires to recompile the SCClass Library in order for the changes in your Creature subclass code to become available. 

*** Simple way:
Code the synth or task process directly:
#+begin_src sclang
	bizz {
		{ PinkNoise.ar(Env.perc(0.01, 0.1).kr(2)).dup / 10 }.play;
	}
#+end_src

Tasks or synths made this way are not tracked by your creature an cannot be stopped later. You may be ok with this if you have coded these synths or tasks to work once started without any further control. See the next section on how to enable basic control of your synth by adding it to the dependants of your creature. 

*** Use add to connect your creature with the synth or task for later control
If you want to add the synth to the dependants of your creature in order to control it later, then use add, or one of the methods described in section 4.3 below.  The most basic case uses the =add= method, like this:

#+begin_src sclang
	addBizz {
		this add: { PinkNoise.ar(Env.perc(0.01, 0.1).kr(2)).dup / 10 }.play;
	}
#+end_src

** 4.3 Methods for registering and controlling 
These methods premit to add synths and tasks and then stop them with other messages.  They only work on synths or tasks that have been added to the dependants of the creature with =add= or related methods (=addTask=, =addLoop=, =substitute=, =substituteTimed=). 

*** add(<synth or playing task>)

Add a synth or task. This does *not* stop previously running synths or tasks. If you want to stop previously running synths or tasks, call method =release=, or use method =substitute=, which stops previously running processes before addin the new process.

**** Add a synth
#+begin_src sclang
	day {
		this add: { WhiteNoise.ar(0.1).dup }.play;
	}
#+end_src

**** Add a task:
#+begin_src sclang
	day {
		this add: Task({ loop { ().play; 1.wait } }).play;
	}
#+end_src

*** addTask(<function for task>)

Shortcut for making a task and adding it. Instead of:
#+begin_src sclang
	day {
		this add: Task({ loop { ().play; 1.wait } }).play;
	}
#+end_src

write:
#+begin_src sclang
	day {
		this addTask: { loop { ().play; 1.wait } };
	}
#+end_src

*** addLoop((<function to be looped in a task>)

Shortcut for looping a function in a task and adding it. Instead of:
#+begin_src sclang
	day {
		this add: Task({ loop { ().play; 1.wait } }).play;
		1.wait;
	}
#+end_src

write:

#+begin_src sclang
	day {
		this addLoop: { ().play; 1.wait };
	}
#+end_src

*** Add synths or tasks running for predefined duration

**** addTimed(<synth or task>, dur = 1, releaseTime ~ 0.05)

Shortcut to add a synth or task, and stop it after =dur= seconds, with release time =releaseTime=.

#+begin_src sclang
day {
		this.addTimed({ WhiteNoise.ar(0.1).dup }.play, 2, 0.3);
	}
#+end_src

*** Substitute previously running processes with a new one

Stop all previously running processes, and then add a new process.

**** substitute(<synth or task>, releaseTime = 0.05)

#+begin_src sclang
	day {
		this.substitute({ LFNoise1.ar(500, 0.1).dup }, 2).play;
	}
#+end_src

**** substituteTimed(<synth or task, dur = 1, releaseTime = 0.05 |)

Stop all previously running processes, and then add a new process running for predefined duration =dur=.

#+begin_src sclang
	day {
		this.substituteTimed({ LFNoise1.ar(900, 0.1).dup }.play, 0.5, 0.02);
	}
#+end_src


*** Release(releaseTime = 0.05) (stop) all running synths and tasks

Release (stop) all running synths and tasks with releaseTime as release time.

#+begin_src sclang
	night {
		this.release(5);
	}
#+end_src


*** Set the parameters of synths

**** set(<parameter1>, <value1>, <parameter2>, <value2>)

#+begin_src sclang
	night {
		this.set(\freq, 100);
	}
#+end_src


* 5. Start the piece 

** Starting a simulation of the environment 

Add some creatues to the environment and start a task that loops through given states with given timings:

#+begin_src sclang
~task = EvoLab.play(
	[Cricket], // creatures in your environment
	[           // list of states and how long each one lasts
		morning: 5,
		day: 8,
		noon: 3,
		afternoon: 4,
		evening: 3,
		night: 5
	],
	5   // number of repetitions
);

** Stop the simulation loop task:

#+begin_src sclang
~task.stop;
#+end_src

** Stop all sounds on all creatures in the environment:

#+begin_src sclang
EvoLab release: 10;
#+end_src

* 6. Submit your code and audio file in a repository.

1. Create a repository on github
2. Upload your Creature class code in the repository, as a file named =MyCreature.sc=, where =MyCreature= is the name of your creature.
3. In the same repository, create a folder called =AudioFile=.
4. In the =AudioFile= folder, put your audio file. It should be a single channel wav file, named like that: =mycreature.wav=.  Use lower case, start with an alphabetic character, and use only alphanumeric characters, for your audio file name. 

* More info

See further example files in folder: =ExampleCode= 
